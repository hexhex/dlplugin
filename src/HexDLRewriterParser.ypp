/* -*- C++ -*- */

/**
 * @file   HexDLRewriterParser.ypp
 * @author Thomas Krennwallner
 * @date   Tue Jul 25 07:44:58 2006
 * 
 * @brief  A bison C++ parser.
 * 
 * 
 */


%skeleton "lalr1.cc"
%define "parser_class_name" "HexDLRewriterParser"
%defines
%file-prefix = "HexDLRewriterParser"
%require "2.2"

%{
#include "HexDLRewriterDriver.h"
#include "HexDLRewriter.h"

#include <dlvhex/Term.h>
#include <dlvhex/Program.h>
#include <dlvhex/Rule.h>

#include <iosfwd>
#include <string>
#include <iterator>

#include <boost/ptr_container/ptr_vector.hpp>

  // why do we need this forward declaration?
  namespace dlvhex {
    namespace dl {
      class HexDLRewriterDriver;
    }
  }

%}

// this is the parsing context, passed as parameters to the
// yy::HexDLRewriterParser ctor
%parse-param { dlvhex::dl::HexDLRewriterDriver& driver }
%parse-param { Program& program }

// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { dlvhex::dl::HexDLRewriterDriver& driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
%debug
%error-verbose
%verbose /* really verbose output */

// this is YYSTYPE, the semantics
%union {
  std::string* sval;
  int ival;
  Term* termval;
  Tuple* tupleval;
  RuleHead_t* headval;
  AtomPtr* opval;
  AtomSet* opsval;
  dlvhex::dl::BodyRewriter* bodyval;
  dlvhex::dl::HexDLRewriterBase* rewriterval;
}

%token <sval> STRING ATOM INFIXATOM
%token <ival> NUMBER
%token DLATOM CQATOM NOT DISJ CONS WCONS
%type <headval> head
%type <bodyval> body
%type <rewriterval> cqatom dlatom literal
%type <opval> op
%type <opsval> ops
%type <termval> term
%type <tupleval> terms output

// define FlexLexer part *after* the definitions of the various types
%{

#include "HexDLRewriterFlexLexer.h"

// Announce to bison the prototype we want for the lexing function
#define YY_DECL                                                 \
yy::HexDLRewriterParser::token_type                             \
yylex (yy::HexDLRewriterParser::semantic_type* yylval,          \
       yy::HexDLRewriterParser::location_type* yylloc,          \
       dlvhex::dl::HexDLRewriterDriver& driver)

// declare YY_DECL function for the parser
YY_DECL;

%}

// automagically delete all dynamically allocated objects after the
// parsing process
%destructor { delete $$; } STRING ATOM INFIXATOM head body

// in debugging mode output the content of the corresponding terminal
// symbol
%printer    { debug_stream() << *$$; } STRING ATOM INFIXATOM dlatom cqatom literal

%%

// either an empty program or a list of rules
prog: /* empty */
    | prog rule
    ;


// a rule is one of these
rule: head CONS body '.'
      {
	//
	// create new rule
	//
	RuleBody_t* body = $3->getBody();
	Rule* r = new Rule(*$1, *body);
	program.addRule(r);

	delete $1;
	delete body;
	delete $3;
      }
    | head '.'
      {
	//
	// add new fact
	//
	Rule* r = new Rule(*$1, RuleBody_t());
	program.addRule(r);

	delete $1;
      }
    | CONS body '.'
      {
	//
	// create new constraint
	//
	RuleBody_t* body = $2->getBody();
	Rule* r = new Rule(RuleHead_t(), *body);
	program.addRule(r);

	delete body;
	delete $2;
      }
    | WCONS body '.' '[' NUMBER ':' NUMBER ']'
      {
	Term w($5);
	Term l($7);
	RuleBody_t* body = $2->getBody();

	WeakConstraint* wc = new WeakConstraint(*body, w, l);

	program.addWeakConstraint(wc);

	delete body;
	delete $2;
      }
    | WCONS body '.' '[' NUMBER ':' ']'
      {
	Term w($5);
	Term l(1);
	RuleBody_t* body = $2->getBody();

	WeakConstraint* wc = new WeakConstraint(*body, w, l);

	program.addWeakConstraint(wc);

	delete body;
	delete $2;
      }
    | WCONS body '.' '[' NUMBER ']'
      {
	Term w(1);
	Term l($5);
	RuleBody_t* body = $2->getBody();

	WeakConstraint* wc = new WeakConstraint(*body, w, l);

	program.addWeakConstraint(wc);

	delete body;
	delete $2;
      }
    | WCONS body '.'
      {
	Term w(1);
	Term l(1);
	RuleBody_t* body = $2->getBody();

	WeakConstraint* wc = new WeakConstraint(*body, w, l);

	program.addWeakConstraint(wc);

	delete body;
	delete $2;
      }
    ;


head: ATOM
      {
	$$ = new RuleHead_t;
	AtomPtr ap(new Atom(*$1));
	$$->push_back(ap);
	delete $1;
      }
    | head DISJ ATOM
      {
	$$ = $1;

	AtomPtr ap(new Atom(*$3));
	$$->push_back(ap);

	delete $3;
      }


// the body contains literals
body: literal
      {
	$$ = new dlvhex::dl::BodyRewriter;
	$$->add($1);
      }
    | body ',' literal
      {
	$$ = $1;
	$$->add($3);
      }
    ;


// a literal is either an expression we don't care about,
// i.e. anything but dl-atoms and cq-atoms, or a cq-atom/dl-atom
literal: ATOM
         {
	   $$ = new dlvhex::dl::LiteralRewriter($1);
	   delete $1;
 	 }
       | NOT ATOM
         {
	   $$ = new dlvhex::dl::LiteralRewriter($2);
	   $$->setNAF(true);
	   delete $2;
	 }
       | INFIXATOM
         {
	   std::string::size_type pbeg = $1->find_first_of("!=<>");
	   std::string::size_type pend = $1->find_first_not_of("!=<>", pbeg);

	   std::string pred = $1->substr(pbeg, pend - pbeg);

	   std::string tmp = $1->substr(0, pbeg);
	   Term t1(tmp.substr(0, tmp.find_first_of(" \t")));
	   Term t2($1->substr($1->find_first_not_of(" \t", pend)));

	   $$ = new dlvhex::dl::LiteralRewriter(new BuiltinPredicate(t1, t2, pred));
	   delete $1;
	 }
       | cqatom
         {
	   $$ = $1;
 	 }
       | dlatom
         {
	   $$ = $1;
	 }
       | NOT cqatom
         {
	   $2->setNAF(true);
	   $$ = $2;
 	 }
       | NOT dlatom
         {
	   $2->setNAF(true);
	   $$ = $2;
	 }
       ;


// a cq-atom is the external atom &dlCQ[uri,a,b,c,d,q](X_1,...X_n), we
// rewrite it to &dlCQn[uri,a,b,c,d,q](X_1,...,X_n)
cqatom: CQATOM '[' terms ']' output
        {
	  $$ = new dlvhex::dl::CQAtomRewriter($3, $5);
	}
      ;


// the output list
output: /* empty */
        {
	  $$ = new Tuple;
	}
      | '(' ')'
        {
	  $$ = new Tuple;
	}
      | '(' terms ')'
        {
	  $$ = $2;
	}
      ;


// list of terms
terms: term
       {
	 $$ = new Tuple(1, *$1);
	 delete $1;
       }
     | terms ',' term
       {
	 $$ = $1;
	 $$->push_back(*$3);
	 delete $3;
       }
     ;


// a term is either a string, a number or an anonymous variable
term: STRING
      {
	$$ = new Term(*$1);
	delete $1;
      }
    | NUMBER
      {
	$$ = new Term($1);
      }
    | '_'
      {
	$$ = new Term;
      }
    ;


// we rewrite dl-atoms to &dlC/&dlR/&dlDR external atoms
dlatom: DLATOM '[' STRING ']' output
        {
	  AtomSet as; // no dl-atom ops
	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getOntology(), as, $3, $5);
	}
      | DLATOM '[' ops ';' STRING ']' output
        {
	  dlvhex::dl::DLAtomRewriter* dlatomrewriter =
	    new dlvhex::dl::DLAtomRewriter(driver.getOntology(),
					   *$3, $5, $7);

	  $$ = dlatomrewriter;

	  delete $3;

	  //
	  // add the input rules to the program
	  //

	  std::vector<Rule*> rules = dlatomrewriter->getDLInputRules();

	  for (std::vector<Rule*>::const_iterator it = rules.begin();
	       it != rules.end(); ++it)
	    {
	      ///@todo if 2 dl-atoms have the same input-predicate, we
	      ///get the same rules twice -> use a set in Program?
	      program.addRule(*it);
	    }
	}
      ;


// list of operations
ops: op
     {
       $$ = new AtomSet;
       $$->insert(*$1);
       delete $1;
     }
   | ops ',' op
     {
       $$ = $1;
       $$->insert(*$3);
       delete $3;
     }
   ;


// an operation is either lhs += rhs or lhs -= rhs. We register them
// at so we can append the rewritten rules for the input of the
// dl-atoms after the parsing process.
op: STRING '+' '=' STRING
    {
      Tuple t;
      t.push_back(Term(*$1, true));
      t.push_back(Term(*$4));

      $$ = new AtomPtr(new Atom("p", t));

      delete $1;
      delete $4;
    }
  | STRING '-' '=' STRING
    {
      Tuple t;
      t.push_back(Term(*$1, true));
      t.push_back(Term(*$4));

      $$ = new AtomPtr(new Atom("m", t));

      delete $1;
      delete $4;
    }
  ;


%%


//
// error method of bison parser -> call error method of the
// corresponding driver
//
void
yy::HexDLRewriterParser::error(const yy::HexDLRewriterParser::location_type& l,
			       const std::string& m)
{
  driver.error(l, m);
}


//
// abuse YY_DECL as bison callback for a pure C++ parsing engine
//
YY_DECL
{
  HexDLRewriterFlexLexer* lex = driver.getLexer();
  lex->lexval = yylval; // set current semantic value
  lex->lexloc = yylloc; // and the current location,
  return (yy::HexDLRewriterParser::token_type) lex->yylex (); // finally call the drivers lexer
} 
