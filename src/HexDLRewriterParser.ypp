/* -*- C++ -*- */

/**
 * @file   HexDLRewriterParser.ypp
 * @author Thomas Krennwallner
 * @date   Tue Jul 25 07:44:58 2006
 * 
 * @brief  A bison C++ parser.
 * 
 * 
 */


%skeleton "lalr1.cc"
%define "parser_class_name" "HexDLRewriterParser"
%defines
%file-prefix = "HexDLRewriterParser"
%require "2.2"

%{
#include "HexDLRewriterDriver.h"
#include "HexDLRewriter.h"

#include <dlvhex/Term.h>
#include <dlvhex/Program.h>
#include <dlvhex/Rule.h>
#include <dlvhex/AggregateAtom.h>

#include <iosfwd>
#include <string>
#include <iterator>

#include <boost/ptr_container/ptr_vector.hpp>

  // why do we need this forward declaration?
  namespace dlvhex {
    namespace dl {
      class HexDLRewriterDriver;
    }
  }

%}

// this is the parsing context, passed as parameters to the
// yy::HexDLRewriterParser ctor
%parse-param { dlvhex::dl::HexDLRewriterDriver& driver }
%parse-param { Program& program }
%parse-param { AtomSet& edb }
%parse-param { dlvhex::dl::DLAtomInput& dlinput }

// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { dlvhex::dl::HexDLRewriterDriver& driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
%debug
%error-verbose
%verbose /* really verbose output */

// this is YYSTYPE, the semantics
%union {
  std::string* sval;
  int ival;
  Term* termval;
  Tuple* tupleval;
  AggregateAtom* aggval;
  Literal* litval;
  RuleHead_t* headval;
  RuleBody_t* bodyval;
  AtomPtr* atomval;
  AtomSet* opsval;
  dlvhex::dl::DLAtomRewriterBase* dlrewriterval;
}

%token <sval> STRING COMP DLEXTATOM
%token <ival> NUMBER
%token NEG PLUSOP MINUSOP DLATOM CQATOM NOT DISJ CONS WCONS
%type <sval> dlquery
%type <headval> head
%type <bodyval> body
%type <litval> literal
%type <dlrewriterval> dlatom
%type <atomval> op atom builtin aggregate
%type <aggval> agg
%type <opsval> ops
%type <termval> term
%type <tupleval> terms output

// define FlexLexer part *after* the definitions of the various types
%{

#include "HexDLRewriterFlexLexer.h"

// Announce to bison the prototype we want for the lexing function
#define YY_DECL                                                 \
yy::HexDLRewriterParser::token_type                             \
yylex (yy::HexDLRewriterParser::semantic_type* yylval,          \
       yy::HexDLRewriterParser::location_type* yylloc,          \
       dlvhex::dl::HexDLRewriterDriver& driver)

// declare YY_DECL function for the parser
YY_DECL;

%}

// automagically delete all dynamically allocated objects after the
// parsing process
%destructor { delete $$; } STRING head body dlatom literal

// in debugging mode output the content of the corresponding terminal
// symbol
%printer    { debug_stream() << *$$; } STRING literal

%%

// either an empty program or a list of rules
prog: /* empty */
    | prog rule
    ;


// a rule is one of these
rule: head CONS body '.'
      {
	//
	// create new rule
	//
	program.addRule(new Rule(*$1, *$3));

	delete $1;
	delete $3;
      }
    | head '.'
      {
	if ($1->size() > 1) // disjunctive head
	  {
	    program.addRule(new Rule(*$1, RuleBody_t()));
	  }
	else // fact
	  {
	    edb.insert($1->front());
	  }

	delete $1;
      }
    | CONS body '.'
      {
	//
	// create new constraint
	//
	program.addRule(new Rule(RuleHead_t(), *$2));

	delete $2;
      }
    | WCONS body '.' '[' NUMBER ':' NUMBER ']'
      {
	Term w($5);
	Term l($7);

	program.addWeakConstraint(new WeakConstraint(*$2, w, l));

	delete $2;
      }
    | WCONS body '.' '[' NUMBER ':' ']'
      {
	Term w($5);
	Term l(1);

	program.addWeakConstraint(new WeakConstraint(*$2, w, l));

	delete $2;
      }
    | WCONS body '.' '[' NUMBER ']'
      {
	Term w(1);
	Term l($5);

	program.addWeakConstraint(new WeakConstraint(*$2, w, l));

	delete $2;
      }
    | WCONS body '.'
      {
	Term w(1);
	Term l(1);

	program.addWeakConstraint(new WeakConstraint(*$2, w, l));

	delete $2;
      }
    ;


// the head of a rule
head: atom
      {
	$$ = new RuleHead_t;
	$$->push_back(*$1);
	delete $1;
      }
    | head DISJ atom
      {
	$$ = $1;
	$$->push_back(*$3);
	delete $3;
      }


// the body contains literals
body: literal
      {
	$$ = new RuleBody_t(1, $1);
      }
    | body ',' literal
      {
	$$ = $1;
	$$->push_back($3);
      }
    ;



// dispatch all kinds of literals
literal: atom
         {
	   $$ = new Literal(*$1);
	   delete $1;
 	 }
       | NOT atom
         {
	   $$ = new Literal(*$2, true);
	   delete $2;
	 }
       | dlatom
         {
	   $$ = $1->getLiteral();
	   delete $1;
	 }
       | NOT dlatom
         {
	   $2->setNAF(true);
	   $$ = $2->getLiteral();
	   delete $2;
	 }
       | builtin
         {
	   $$ = new Literal(*$1);
	   delete $1;
	 }
       | aggregate
         {
	   $$ = new Literal(*$1);
	   delete $1;
	 }
       | NOT aggregate
         {
	   $$ = new Literal(*$2, true);
	   delete $2;
	 }
       ;


// ordinary and higher order, as well as non-dl external atoms
atom: STRING output
      {
	$$ = new AtomPtr(new Atom(*$1, *$2));
	delete $1;
	delete $2;
      }
    | NEG STRING output
      {
	$$ = new AtomPtr(new Atom(*$2, *$3, true));
	delete $2;
	delete $3;
      }
    | '&' STRING '[' terms ']' output
      {
	$$ = new AtomPtr(new ExternalAtom(*$2, *$6, *$4, (@1.end-1).line));
	delete $2;
	delete $4;
	delete $6;
      }
    ;


// a builtin
builtin: term COMP term
         {
	   // fixme: use atomptr instead of atom*
 	   $$ = new AtomPtr(new BuiltinPredicate(*$1, *$3, *$2));
 	   delete $1;
 	   delete $2;
 	   delete $3;
         }
       | COMP '(' term ',' term ')'
         {
	   // fixme: use atomptr instead of atom*
 	   $$ = new AtomPtr(new BuiltinPredicate(*$3, *$5, *$1));
 	   delete $1;
 	   delete $3;
 	   delete $5;
         }
       ;


// an aggregate is of form X comp #xyz{..}, #xyz{..} comp X or X comp
// #xyz{..} comp Y
aggregate: term COMP agg
           {
	     $3->setComp(*$2, "");
	     $3->setLeftTerm(*$1);
	     $$ = new AtomPtr($3);
	     delete $1;
	     delete $2;
	   }
         | agg COMP term
           {
	     $1->setComp("", *$2);
	     $1->setRightTerm(*$3);
	     $$ = new AtomPtr($1);
	     delete $2;
	     delete $3;
	   }
         | term COMP agg COMP term
           {
	     $3->setComp(*$2, *$4);
	     $3->setLeftTerm(*$1);
	     $3->setRightTerm(*$5);
	     $$ = new AtomPtr($3);
	     delete $1;
	     delete $2;
	     delete $4;
	     delete $5;
	   }
         ;


// an aggregate atom is an atom of form #xyz{ X1,...,Xn : b(X_1),...,b(X_n) }
agg: '#' STRING '{' terms ':' body '}'
     {
       try
	 {
	   $$ = new AggregateAtom("#" + *$2, *$4, *$6);
	 }
       catch (SyntaxError& e)
	 {
	   error(yylloc, e.what());
	 }

       delete $2;
       delete $4;
       delete $6;
     }
   ;


// This rule keeps track of the various forms of the dl-atom
// rewriters. We rewrite dl-atoms to &dlC/&dlR/&dlDR external atoms,
// &dl{C,R} and &dlCQ external atoms are handled here as well.
dlatom: DLATOM '[' dlquery ']' output
        {
	  //
	  // create a rewriter without dl-atom ops
	  //
	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getOntology(), dlinput, AtomSet(), $3, $5);
	}
      | DLATOM '[' ops ';' dlquery ']' output
        {
	  //
	  // create a rewriter with dl-atom ops
	  //

	  dlvhex::dl::DLAtomRewriter* dlatomrewriter =
	    new dlvhex::dl::DLAtomRewriter(driver.getOntology(), dlinput, *$3, $5, $7);

	  $$ = dlatomrewriter;

	  delete $3;

	  //
	  // add the input rules to the program
	  //

	  std::vector<Rule*> rules = dlatomrewriter->getDLInputRules();

	  for (std::vector<Rule*>::const_iterator it = rules.begin();
	       it != rules.end(); ++it)
	    {
	      ///@todo if 2 dl-atoms have the same input-predicate, we
	      ///get the same rules twice -> use a set in Program?
	      program.addRule(*it);
	    }
	}
      | CQATOM '[' terms ']' output
        { 
	  // a cq-atom is the external atom
	  // &dlCQ[uri,a,b,c,d,q](X_1,...X_n), we rewrite it to
	  // &dlCQn[uri,a,b,c,d,q](X_1,...,X_n)
	  $$ = new dlvhex::dl::CQAtomRewriter($3, $5);
	}
      | DLEXTATOM '[' terms ']' output
        {
	  // create simple dlatom rewriter
	  $$ = new dlvhex::dl::SimpleDLAtomRewriter($1, $3, $5);
	}
      ;


// a dl-query is a STRING or a negated STRING
dlquery: STRING
         {
	   $$ = $1;
	 }
       | NEG STRING
         {
	   $$ = $2;
	   $$->insert(0, 1, '-');
	 }
       ;


// the output list
output: /* empty */
        {
	  $$ = new Tuple;
	}
      | '(' ')'
        {
	  $$ = new Tuple;
	}
      | '(' terms ')'
        {
	  $$ = $2;
	}
      ;


// list of terms
terms: term
       {
	 $$ = new Tuple(1, *$1);
	 delete $1;
       }
     | terms ',' term
       {
	 $$ = $1;
	 $$->push_back(*$3);
	 delete $3;
       }
     ;


// a term is either a string, a number or an anonymous variable
term: STRING
      {
	$$ = new Term(*$1);
	delete $1;
      }
    | NUMBER
      {
	$$ = new Term($1);
      }
    | '_'
      {
	$$ = new Term;
      }
    ;



// list of operations
ops: op
     {
       $$ = new AtomSet;
       $$->insert(*$1);
       delete $1;
     }
   | ops ',' op
     {
       $$ = $1;
       $$->insert(*$3);
       delete $3;
     }
   ;


// an operation is either lhs += rhs or lhs -= rhs. For each lhs+=rhs
// resp. lhs-=rhs we create a p(lhs,rhs) resp. m(lhs,rhs) atom. Then,
// the DLAtomRewriter takes care of adding rules and input terms to
// the ext-atoms.
op: STRING PLUSOP STRING
    {
      Tuple t;
      t.push_back(Term(*$1, true));
      t.push_back(Term(*$3));

      $$ = new AtomPtr(new Atom("p", t));

      delete $1;
      delete $3;
    }
  | STRING MINUSOP STRING
    {
      Tuple t;
      t.push_back(Term(*$1, true));
      t.push_back(Term(*$3));

      $$ = new AtomPtr(new Atom("m", t));

      delete $1;
      delete $3;
    }
  ;


%%


//
// error method of bison parser -> call error method of the
// corresponding driver
//
void
yy::HexDLRewriterParser::error(const yy::HexDLRewriterParser::location_type& l,
			       const std::string& m)
{
  driver.error(l, m);
}


//
// abuse YY_DECL as bison callback for a pure C++ parsing engine
//
YY_DECL
{
  HexDLRewriterFlexLexer* lex = driver.getLexer();
  lex->lexval = yylval; // set current semantic value
  lex->lexloc = yylloc; // and the current location,
  return (yy::HexDLRewriterParser::token_type) lex->yylex (); // finally call the drivers lexer
} 
