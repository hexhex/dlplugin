/* -*- C++ -*- */

/**
 * @file   HexDLRewriterParser.ypp
 * @author Thomas Krennwallner
 * @date   Tue Jul 25 07:44:58 2006
 * 
 * @brief  A bison C++ parser.
 * 
 * 
 */


%skeleton "lalr1.cc"
%define "parser_class_name" "HexDLRewriterParser"
%defines
%file-prefix = "HexDLRewriterParser"
%require "2.2"

%{
#include "HexDLRewriterDriver.h"
#include "HexDLRewriter.h"

#include <dlvhex/Term.h>

#include <iosfwd>
#include <string>
#include <iterator>

#include <boost/ptr_container/ptr_vector.hpp>

  // why do we need this forward declaration?
  namespace dlvhex {
    namespace dl {
      class HexDLRewriterDriver;
    }
  }

%}

// this is the parsing context, passed as parameters to the
// yy::HexDLRewriterParser ctor
%parse-param { dlvhex::dl::HexDLRewriterDriver& driver }

// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { dlvhex::dl::HexDLRewriterDriver& driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
%debug
%error-verbose
%verbose /* really verbose output */

// this is YYSTYPE, the semantics
%union {
  std::string* sval;
  int ival;
  Term* termval;
  Tuple* tupleval;
  dlvhex::dl::BodyRewriter* bodyval;
  dlvhex::dl::HexDLRewriterBase* rewriterval;
}

%token <sval> STRING LITERAL
%token <ival> NUMBER
%token DLATOM CQATOM NOT
%type <sval> dlquery
%type <bodyval> body
%type <rewriterval> cqatom dlatom literal
%type <termval> term
%type <tupleval> terms output

// define FlexLexer part *after* the definitions of the various types
%{

#include "HexDLRewriterFlexLexer.h"

// Announce to bison the prototype we want for the lexing function
#define YY_DECL                                                 \
yy::HexDLRewriterParser::token_type                             \
yylex (yy::HexDLRewriterParser::semantic_type* yylval,          \
       yy::HexDLRewriterParser::location_type* yylloc,          \
       dlvhex::dl::HexDLRewriterDriver& driver)

// declare YY_DECL function for the parser
YY_DECL;

%}

// automagically delete all dynamically allocated objects after the
// parsing process
%destructor { delete $$; } STRING body

// in debugging mode output the content of the corresponding terminal
// symbol
%printer    { debug_stream() << *$$; } STRING LITERAL dlquery dlatom cqatom literal

%%

prog: /* empty */
    | prog rule
    ;


// we only rewrite the body of a rule
rule: body '.'
      {
	driver.getOutput() << ' ' << *$1 << '.';
	delete $1;
      }
    ;


// the body contains literals
body: literal
      {
	$$ = new dlvhex::dl::BodyRewriter;
	$$->add($1);
      }
    | body ',' literal
      {
	$$ = $1;
	$$->add($3);
      }
    ;


// a literal is either an expression we don't care about,
// i.e. anything but dl-atoms and cq-atoms, or a cq-atom/dl-atom
literal: LITERAL
         {
	   $$ = new dlvhex::dl::LiteralRewriter($1);
 	 }
       | cqatom
         {
	   $$ = $1;
 	 }
       | dlatom
         {
	   $$ = $1;
	 }
       | NOT cqatom
         {
	   $2->setNAF(true);
	   $$ = $2;
 	 }
       | NOT dlatom
         {
	   $2->setNAF(true);
	   $$ = $2;
	 }
       ;


// a cq-atom is the external atom &dlCQ[uri,a,b,c,d,q](X_1,...X_n), we
// rewrite it to &dlCQn[uri,a,b,c,d,q](X_1,...,X_n)
cqatom: CQATOM '[' terms ']' output
        {
	  $$ = new dlvhex::dl::CQAtomRewriter($3, $5);
	}
      ;


// the output list
output: /* empty */
        {
	  $$ = new Tuple;
	}
      | '(' ')'
        {
	  $$ = new Tuple;
	}
      | '(' terms ')'
        {
	  $$ = $2;
	}
      ;


// list of terms
terms: term
       {
	 $$ = new Tuple(1, *$1);
	 delete $1;
       }
     | terms ',' term
       {
	 $$ = $1;
	 $$->push_back(*$3);
	 delete $3;
       }
     ;


// a term is either a string, a number or an anonymous variable
term: STRING
      {
	$$ = new Term(*$1);
	delete $1;
      }
    | NUMBER
      {
	$$ = new Term($1);
      }
    | '_'
      {
	$$ = new Term;
      }
    ;


// we rewrite dl-atoms to &dlC/&dlR external atoms
dlatom: DLATOM dlquery '(' STRING ')'
        {
	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getUri(),
					      driver.getExtAtomNo(),
					      $2,
					      $4);
	  driver.addExtAtomNo(1);
	}
      | DLATOM dlquery '(' STRING ',' STRING ')'
        {
	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getUri(),
					      driver.getExtAtomNo(),
					      $2,
					      $4,
					      $6);
	  driver.addExtAtomNo(1);
	}
      ;


// a dlquery is either an input list with operations and a query or
// just a query
dlquery: '[' ops ';' STRING ']'
         {
	   $$ = $4;
	 }
       | '[' STRING ']'
         {
	   $$ = $2;
	 }
       ;


// list of operations
ops: op
   | ops ',' op
   ;


// an operation is either lhs += rhs or lhs -= rhs. We register them
// at so we can append the rewritten rules for the input of the
// dl-atoms after the parsing process.
op: STRING '+' '=' STRING
    {
      driver.registerDLOp(new dlvhex::dl::HexDLRewriterDriver::DLAtomOp
			  (driver.getExtAtomNo(),
			   dlvhex::dl::HexDLRewriterDriver::DLAtomOp::plus,
			   $1,
			   $4
			   )
			  );
    }
  | STRING '-' '=' STRING
    {
      driver.registerDLOp(new dlvhex::dl::HexDLRewriterDriver::DLAtomOp
			  (driver.getExtAtomNo(),
			   dlvhex::dl::HexDLRewriterDriver::DLAtomOp::minus,
			   $1,
			   $4
			   )
			  );
    }
  ;


%%


//
// error method of bison parser -> call error method of the
// corresponding driver
//
void
yy::HexDLRewriterParser::error(const yy::HexDLRewriterParser::location_type& l,
			       const std::string& m)
{
  driver.error(l, m);
}


//
// abuse YY_DECL as bison callback for a pure C++ parsing engine
//
YY_DECL
{
  HexDLRewriterFlexLexer* lex = driver.getLexer();
  lex->lexval = yylval; // set current semantic value
  lex->lexloc = yylloc; // and the current location,
  return (yy::HexDLRewriterParser::token_type) lex->yylex (); // finally call the drivers lexer
} 
