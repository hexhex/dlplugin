/* -*- C++ -*- */

/**
 * @file   HexDLRewriterScanner.lpp
 * @author Thomas Krennwallner
 * @date   Tue Jul 25 07:37:43 2006
 * 
 * @brief  Defines HexDLRewriterFlexLexer::yylex() method.
 * 
 * 
 */

%{
#include "HexDLRewriterParser.hpp"
#include "HexDLRewriterDriver.h"
#include "HexDLRewriterFlexLexer.h"

// keep the HexDLRewriterFlexLexer as close as possible to the C version
#define yylval (*(yy::HexDLRewriterParser::semantic_type*)lexval)
#define yylloc ((yy::HexDLRewriterParser::location_type*)lexloc)
#define driver (*lexdrv)
%}

%option c++ noyywrap nounput batch debug
%option yyclass="HexDLRewriterFlexLexer"
%option prefix="yyHex"

NEWLINE         \r?\n
BLANK           [ \t]
STRING          ("-"|"~")?[A-Za-z][A-Za-z_0-9\']*
QUOTED_STRING   \"[^\"]*\"
NUMBER          (\-)?[0-9]+

COMMENT         {BLANK}*%.*{NEWLINE}

CONS            (:-|<-)
WCONS           :~

INPUTLIST       \[[^\]]+\]
OUTPUTLIST      \([^\)]*\)

DLATOM          DL{INPUTLIST}{OUTPUTLIST}
DLCATOM         &dlC{INPUTLIST}{OUTPUTLIST}
DLRATOM         &dlR{INPUTLIST}{OUTPUTLIST}
DLDRATOM        &dlDR{INPUTLIST}{OUTPUTLIST}
CQATOM          &dlCQ{INPUTLIST}{OUTPUTLIST}?

NAF             ("not"|"non"){BLANK}+
DISJ            {BLANK}+v{BLANK}+

ATOM            ({STRING}|{QUOTED_STRING}){OUTPUTLIST}?
EXTATOM         &{STRING}{INPUTLIST}{OUTPUTLIST}?
INFIXATOM       {STRING}{BLANK}*("="|"!="|"<>"|"=="|"<"|">"|"<="|">="){BLANK}*({STRING}|{NUMBER})({BLANK}*("+"|"-"|"*"|"/"){BLANK}*({STRING}|{NUMBER}))?
AGGREGATE       #{STRING}{OUTPUTLIST}

AGGREGATELINE   {AGGREGATE}{NEWLINE}

%x head body atom list

%{
// advance the end location after each tokenizing step
#define YY_USER_ACTION  yylloc->columns(yyleng);
%}

%%

%{
// set begin location to the end location
yylloc->step();
%}

%{
// abbreviate it as token
typedef yy::HexDLRewriterParser::token token;
%}


<*>{COMMENT}  yylloc->lines(1);


<INITIAL>{

  {AGGREGATELINE} {
    // in INITIAL state, we ignore aggregates such as #namespace, #int, ...
    ECHO;
  }

  {ATOM} {
    BEGIN(head);
    // all other kinds of literals are passed as is
    yylval.sval = new std::string(yytext);
    return token::ATOM;
  }

  {WCONS} {
    BEGIN(body);
    return token::WCONS;
  }

  {CONS} {
    BEGIN(body);
    return token::CONS;
  }

  {NUMBER} {
    std::istringstream(yytext) >> yylval.ival;
    return token::NUMBER; 
  }

  [\[\]:] {
    return yy::HexDLRewriterParser::token_type(*yytext);
  }

}


<head>{

  {DISJ} {
    return token::DISJ;
  }

  {ATOM} {
    // all other kinds of literals are passed as is
    yylval.sval = new std::string(yytext);
    return token::ATOM;
  }

  {CONS} {
    BEGIN(body);
    return token::CONS;
  }

}


<body>{

  {NAF} {
    return token::NOT;
  }

  {DLATOM} {
    yyless(2); // skip DL, but rescan the input/output list
    BEGIN(atom);
    return token::DLATOM;
  }

  ({DLCATOM}|{DLRATOM}) {
    yyless(4); // skip &dlC/&dlR, but rescan the input/output list
    BEGIN(atom);
    return token::DLEXTATOM;
  }

  {DLDRATOM} {
    ///@todo right now we skip dldr-atoms
    yylval.sval = new std::string(yytext);
    return token::ATOM;
  }

  {CQATOM} {
    yyless(5); // skip &dlCQ, but rescan the input/output list
    BEGIN(atom);
    return token::CQATOM;
  }

  {INFIXATOM} {
    yylval.sval = new std::string(yytext);
    return token::INFIXATOM;
  }

  ({EXTATOM}|{AGGREGATE}|{ATOM}) {
    // all other kinds of literals are passed as is
    yylval.sval = new std::string(yytext);
    return token::ATOM;
  }

}


<head,body,atom>{

  "." {
    // start over again when the body of a rule is done
    BEGIN(INITIAL);
    return yy::HexDLRewriterParser::token_type(*yytext);
  }


  "," {
    // we got a body separator element, continue as body
    BEGIN(body);
    return yy::HexDLRewriterParser::token_type(*yytext);
  }

}


<atom>[\(\[]  BEGIN(list); return yy::HexDLRewriterParser::token_type(*yytext);


<list>{

  ({STRING}|{QUOTED_STRING}) {
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  {NUMBER} {
    std::istringstream(yytext) >> yylval.ival;
    return token::NUMBER; 
  }

  [\)\]]      BEGIN(atom); return yy::HexDLRewriterParser::token_type(*yytext);

  [\_+-=,]    return yy::HexDLRewriterParser::token_type(*yytext);

}

<*>{BLANK}+   /* skip blanks */ yylloc->step();

<*>{NEWLINE}  yylloc->lines(1);

<*>.          driver.error(*yylloc, "invalid character");

%%

