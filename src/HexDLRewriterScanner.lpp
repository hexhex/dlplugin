/* -*- C++ -*- */

/**
 * @file   HexDLRewriterScanner.lpp
 * @author Thomas Krennwallner
 * @date   Tue Jul 25 07:37:43 2006
 * 
 * @brief  Defines HexDLRewriterFlexLexer::yylex() method.
 * 
 * 
 */

%{
#include "HexDLRewriterParser.hpp"
#include "HexDLRewriterDriver.h"
#include "HexDLRewriterFlexLexer.h"

#include <sstream>

// keep the HexDLRewriterFlexLexer as close as possible to the C version
#define yylval (*(yy::HexDLRewriterParser::semantic_type*)lexval)
#define yylloc ((yy::HexDLRewriterParser::location_type*)lexloc)
#define driver (*lexdrv)
%}

%option c++ noyywrap nounput batch debug
%option yyclass="HexDLRewriterFlexLexer"
%option prefix="yyHex"

NEWLINE         \r?\n
BLANK           [ \t]
STRING          [A-Za-z][A-Za-z_0-9\'\_]*
QUOTED_STRING   \"[^\"]*\"
NUMBER          (\-)?[0-9]+

COMMENT         {BLANK}*%.*{NEWLINE}

CONS            (":-"|"<-")
WCONS           ":~"

NEG             ("-"|"~")
NAF             ("not"|"non"){BLANK}+
DISJ            {BLANK}+v{BLANK}+
COMP            ("="|"!="|"<>"|"=="|"<"|">"|"<="|">=")
PLUSOP          "+="
MINUSOP         "-="

INPUTLIST       \[[^\]]+\]
OUTPUTLIST      \([^\)]+\)

DLATOM          DL{INPUTLIST}{OUTPUTLIST}
DLCATOM         &dlC{INPUTLIST}{OUTPUTLIST}
DLRATOM         &dlR{INPUTLIST}{OUTPUTLIST}
DLDRATOM        &dlDR{INPUTLIST}{OUTPUTLIST}
DLCQATOM        &dlCQ{INPUTLIST}{OUTPUTLIST}?

BUILTINLINE     #{STRING}{BLANK}*\([^\)]*\){BLANK}*{NEWLINE}

%x head body

%{
// advance the end location after each tokenizing step
#define YY_USER_ACTION  yylloc->columns(yyleng);
%}

%%

%{
// set begin location to the end location
yylloc->step();
%}

%{
// abbreviate it as token
typedef yy::HexDLRewriterParser::token token;
%}


<*>{COMMENT}  yylloc->lines(1);


<*>{NEG} {
  return token::NEG;
}


<INITIAL>{

  {BUILTINLINE} {
    yylloc->lines(1);
    // in INITIAL state, we ignore aggregates such as #namespace, #maxint, ...
    ECHO;
  }

  {CONS} {
    BEGIN(body);
    return token::CONS;
  }

  {WCONS} {
    BEGIN(body);
    return token::WCONS;
  }

  ({STRING}|{QUOTED_STRING}) {
    BEGIN(head); // we need this to distinguish 'v' as disjunction in the head
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  [\[\]\:] {
    // for weak constraints
    return yy::HexDLRewriterParser::token_type(*yytext);
  }

}


<head>{

  {DISJ} {
    return token::DISJ;
  }

  ({STRING}|{QUOTED_STRING}) {
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  {CONS} {
    BEGIN(body);
    return token::CONS;
  }

  [\(\)\,\_] {
    return yy::HexDLRewriterParser::token_type(*yytext);
  }

}


<body>{

  {NAF} {
    return token::NOT;
  }

  {DLATOM} {
    yyless(2); // throw away "DL" and continue
    return token::DLATOM;
  }

  ({DLCATOM}|{DLRATOM}) {
    yylval.sval = new std::string(yytext + 1, 3);
    yyless(4); // throw away "&dl(C|R)" and continue
    return token::DLEXTATOM;
  }

  {DLDRATOM} {
    yylval.sval = new std::string(yytext + 1, 4);
    yyless(5); // throw away "&dlDR" and continue
    return token::DLEXTATOM;
  }

  {DLCQATOM} {
    yyless(5); // throw away "&dlCQ" and continue
    return token::CQATOM;
  }

  ({STRING}|{QUOTED_STRING}) {
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  {COMP} {
    yylval.sval = new std::string(yytext);
    return token::COMP;
  }

  {PLUSOP} {
    return token::PLUSOP;
  }

  {MINUSOP} {
    return token::MINUSOP;
  }

  [\(\)\[\]\{\}\,\;\_\+\-\#\&\:] {
    return yy::HexDLRewriterParser::token_type(*yytext);
  }

}


<head,body>"." {
  // start over again when the body of a rule is done
  BEGIN(INITIAL);
  return yy::HexDLRewriterParser::token_type(*yytext);
}


<*>{NUMBER} {
  std::istringstream(yytext) >> yylval.ival;
  return token::NUMBER; 
}


<*>{BLANK}+   /* skip blanks */ yylloc->step();


<*>{NEWLINE}  yylloc->lines(1);


<*>.          driver.error(*yylloc, "invalid character");

%%

