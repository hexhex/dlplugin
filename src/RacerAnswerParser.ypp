/*  -*- C++ -*- */

/**
 * @file   RacerAnswerParser.ypp
 * @author Thomas Krennwallner
 * @date   Fri Mar 17 21:59:38 2006
 * 
 * @brief  
 * 
 * 
 */


%skeleton "lalr1.cc"
%define "parser_class_name" "RacerAnswerParser"
%defines
%file-prefix = "RacerAnswerParser"

%{
#include "RacerAnswerDriver.h"
#include "RacerError.h"

#include <string>
%}

// this is the parsing context, passed as parameters to the
// yy::RacerAnswerParser ctor
%parse-param { dlvhex::racer::RacerAnswerDriver& driver }
%parse-param { dlvhex::racer::Answer& answer }

// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { dlvhex::racer::RacerAnswerDriver& driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
%debug
%error-verbose
%verbose /* really verbose output */

// this is YYSTYPE, the semantics
%union {
  int ival;
  std::string* sval;
  Term* termval;
  Tuple* tupleval;
}

%type <termval> identifier;
%type <termval> individual;
%type <tupleval> tuple;
%type <tupleval> pair;

%token <sval> STRING
%token <ival> NUMBER
%token NIL
%token TRUE
%token ANSWER
%token ERROR

// automagically delete all dynamically allocated objects after the
// parsing process (but keep those identifier terms, they are passed
// on to the individuals)
%destructor { delete $$; } STRING individual tuple pair

// in debugging mode output the content of the corresponding terminal
// symbol
%printer    { debug_stream() << *$$; } STRING
%printer    { debug_stream() << $$; } NUMBER

%%

racer: /* empty */
     | ANSWER message '\n'
     | ERROR STRING '\n'
       {
	 answer.setErrorMessage(*$2);

	 // if kb gets inconsistent just return and set incoherent flag
	 if ($2->find("incoherent") != std::string::npos)
	   {
	     answer.setIncoherent(true);
	   }
	 else
	   {
	     throw dlvhex::racer::RacerParsingError(*$2);
	   }
       }
;

// a Racer answer message is either a boolean, a list or a status
message: boolean | list | status
;

// a Racer boolean answer is either "T" or "NIL"
boolean: TRUE
         {
	   answer.setAnswer(true);
	   answer.setTuples(std::vector<Tuple>(1));
	 }
       | NIL
         {
	   answer.setAnswer(false);
	 }
;


// a Racer list is either a list of individuals, a list of pairs or a
// list of tuples
list: '(' individuals ')'
    | '(' pairs ')'
    | '(' tuples ')'
;

// a Racer status message, just ignore it
status: ':' STRING
      | '|' STRING '|'
      | STRING
;

// just add the sequence of individuals to the answer
individuals: individual
           {
	     Tuple t;
	     t.push_back(*$1);
	     answer.addTuple(t);
	   }
           | individuals individual
           {
	     Tuple t;
	     t.push_back(*$2);
	     answer.addTuple(t);
	   }
;

// add the parsed Tuple to the answer
pairs: '(' pair ')' { answer.addTuple(*$2); }
     | pairs '(' pair ')' { answer.addTuple(*$3); }
;

// a Racer pair is a pair of individuals -> use both individuals in a
// new Tuple
pair: individual individual
      {
	$$ = new Tuple;
        $$->push_back(*$1);
        $$->push_back(*$2);
      }
;

// add the parsed Tuple to the answer
tuples: '(' tuple ')' { answer.addTuple(*$2); }
      | tuples '(' tuple ')' { answer.addTuple(*$3); }
;

// a Racer tuple consists of a pair (var ind) -> just use the
// individual
tuple: '(' variable individual ')'
       {
	 $$ = new Tuple;
	 $$->push_back(*$3);
       }
     | tuple '(' variable individual ')'
       {
	 $1->push_back(*$4);
       }
;


// an individual is an identifier (without namespace)
individual: '|' nsid '#' identifier '|' { $$ = $4; }
          | identifier { $$ = $1; }
;

// Racer has 4 types of variables
variable: '?' variableid
        | '$' '?' variableid
        | '?' '*' variableid
        | '$' '?' '*' variableid
;

// this is a rather weak version of a namespace identifier
nsid: STRING ':' '/' '/' STRING
    | STRING ':' STRING
;

variableid: STRING
;

identifier: STRING { $$ = new Term(*$1, true); }
          | NUMBER { $$ = new Term($1); }
;

%%

// error method of bison parser -> call error method of the
// corresponding driver
void
yy::RacerAnswerParser::error (const yy::RacerAnswerParser::location_type& l,
			      const std::string& m)
{
  driver.error(l, m);
}


// bison callback for a pure C++ parsing engine
YY_DECL
{
  RacerFlexLexer* lex = driver.getLexer();
  lex->lexval = yylval;
  lex->lexloc = yylloc;
  return lex->yylex (); // call the drivers lexer
}
