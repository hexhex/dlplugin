/* dlvhex-dlplugin -- Integration of Answer-Set Programming and Description Logics.
 *
 * Copyright (C) 2005, 2006, 2007  Thomas Krennwallner
 * 
 * This file is part of dlvhex-dlplugin.
 *
 * dlvhex-dlplugin is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * dlvhex-dlplugin is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dlvhex-dlplugin; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */


/**
 * @file   RacerAnswerParser.ypp
 * @author Thomas Krennwallner
 * @date   Fri Mar 17 21:59:38 2006
 * 
 * @brief  A bison C++ parser.
 * 
 * 
 */


%skeleton "lalr1.cc"
%define "parser_class_name" "RacerAnswerParser"
%defines
%file-prefix = "RacerAnswerParser"
%require "2.2"

%{
#include <dlvhex/Term.h>

#include "Answer.h"
#include "RacerAnswerDriver.h"
#include "DLError.h"

#include <string>

  // why do we need this forward declaration?
  namespace dlvhex {
    namespace dl {
      namespace racer {
	class RacerAnswerDriver;
      }
    }
  }

%}

// this is the parsing context, passed as parameters to the
// yy::RacerAnswerParser ctor
%parse-param { dlvhex::dl::racer::RacerAnswerDriver& driver }
%parse-param { dlvhex::dl::Answer& answer }

// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { dlvhex::dl::racer::RacerAnswerDriver& driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
%debug
%error-verbose
%verbose /* really verbose output */

// this is YYSTYPE, the semantics
%union {
  int ival;
  std::string* sval;
  Term* termval;
  Tuple* tupleval;
}


// define FlexLexer part *after* the definitions of the various types
%{

#include "RacerFlexLexer.h"

#define YY_DECL \
yy::RacerAnswerParser::token_type \
yylex (yy::RacerAnswerParser::semantic_type* yylval, \
       yy::RacerAnswerParser::location_type* yylloc, \
       dlvhex::dl::racer::RacerAnswerDriver& driver)

// declare YY_DECL function
YY_DECL;

%}

%type <termval> individual;
%type <tupleval> tuple;
%type <tupleval> pair;

%token <sval> STRING
%token <sval> URI
%token <ival> NUMBER
%token NIL
%token TRUE
%token ANSWER
%token ERROR

// automagically delete all dynamically allocated objects after the
// parsing process
%destructor { delete $$; } STRING URI individual pair tuple

// in debugging mode output the content of the corresponding terminal
// symbol
%printer    { debug_stream() << *$$; } STRING URI
%printer    { debug_stream() << $$; } NUMBER

%%

racer: ANSWER message STRING '\n'
       {
	 answer.setWarningMessage(*$3);
	 delete $3;
       }
     | ERROR STRING STRING '\n'
       {
	 answer.setErrorMessage(*$2);
	 delete $2;

	 answer.setWarningMessage(*$3);
	 delete $3;

	 // Racer returns "ABox XXX is incoherent." for 'old' Racer
	 // queries, and "ABox XXX is inconsistent! Querying denied."
	 // for nRQL queries.
	 if (answer.getErrorMessage().find("incoherent") != std::string::npos ||
	     answer.getErrorMessage().find("inconsistent") != std::string::npos)
	   {
	     // if kb gets inconsistent just return without error and
	     // set incoherent flag
	     answer.setIncoherent(true);
	   }
	 else
	   {
	     throw dlvhex::dl::DLParsingError(answer.getErrorMessage());
	   }
       }
;

// a Racer answer message is either a boolean, a list or a status
message: boolean | list | status
;

// a Racer boolean answer is either "T" or "NIL"
boolean: TRUE
         {
	   answer.setAnswer(true);
 	   answer.addTuple(Tuple());
	 }
       | NIL
         {
	   answer.setAnswer(false);
	 }
;


// a Racer list is either a list of individuals, a list of pairs or a
// list of tuples
list: '(' individuals ')'
    | '(' pairs ')'
    | '(' tuples ')'
;

// a Racer status message, just ignore it
status: ':' STRING
        {
	  delete $2;
	}
      | '|' URI '|'
        {
	  delete $2;
	}
      | STRING
        {
	  delete $1;
	}
;

// just add the sequence of individuals to the answer
individuals: individual
             {
	       answer.addTuple(Tuple(1, *$1));
	       delete $1;
	     }
           | individuals individual
             { 
	       answer.addTuple(Tuple(1, *$2));
	       delete $2;
	     }
;

// add the parsed Tuple to the answer
pairs: '(' pair ')'
       {
	 answer.addTuple(*$2);
	 delete $2;
       }
     | pairs '(' pair ')'
       {
	 answer.addTuple(*$3);
	 delete $3;
       }
;

// a Racer pair is a pair of individuals -> use both individuals in a
// new Tuple
pair: individual individual
      {
	$$ = new Tuple;
        $$->push_back(*$1);
        $$->push_back(*$2);
	delete $1;
	delete $2;
      }
;

// add the parsed Tuple to the answer
tuples: '(' tuple ')'
        {
	  answer.addTuple(*$2);
	  delete $2;
	}
      | tuples '(' tuple ')'
        {
	  answer.addTuple(*$3);
	  delete $3;
	}
;

// a Racer tuple consists of a pair (var ind) -> just use the
// individual
tuple: '(' variable individual ')'
       {
	 $$ = new Tuple(1, *$3);
	 delete $3;
       }
     | tuple '(' variable individual ')'
       {
	 $$ = $1;
	 $$->push_back(*$4);
	 delete $4;
       }
;


// an individual is a symbol (maybe with namespace) or a number
individual: '|' URI '|'
            {
	      $$ = new Term(*$2, true);
	      delete $2;
	    }
          | STRING
            {
	      $$ = new Term(*$1, true);
	      delete $1;
	    }
          | NUMBER
            {
	      $$ = new Term($1);
	    }
;

/// @todo the 5th variable type is just a workaround for a Racer bug
/// in nRQL queries like (retrieve (|http://foo#moo|)
/// (|http://foo#moo| *TOP*)), where we get answer pairs like
/// (|$?http://foo#moo| |http://foo#moo|) instead of
/// ($?|http://foo#moo| |http://foo#moo|)

// Racer has 4 types of variables
variable: '?' STRING
          {
	    delete $2;
	  }
        | '$' '?' STRING
          {
	    delete $3;
	  }
        | '?' '*' STRING
          {
	    delete $3;
	  }
        | '$' '?' '*' STRING
          {
	    delete $4;
	  }
        | '|' '$' '?' URI '|'
          {
	    delete $4;
	  }
;

%%

// error method of bison parser -> call error method of the
// corresponding driver
void
yy::RacerAnswerParser::error(const yy::RacerAnswerParser::location_type& l,
			     const std::string& m)
{
  driver.error(l, m);
}


// abuse YY_DECL as bison callback for a pure C++ parsing engine
YY_DECL
{
  RacerFlexLexer* lex = driver.getLexer();
  lex->lexval = yylval; // set current semantic value
  lex->lexloc = yylloc; // and the current location,
  return (yy::RacerAnswerParser::token_type) lex->yylex (); // finally call the drivers lexer
}


// Local Variables:
// mode: C++
// End:
