/*  -*- C++ -*- */

/**
 * @file   RacerAnswerParser.ypp
 * @author Thomas Krennwallner
 * @date   Fri Mar 17 21:59:38 2006
 * 
 * @brief  A bison C++ parser.
 * 
 * 
 */


%skeleton "lalr1.cc"
%define "parser_class_name" "RacerAnswerParser"
%defines
%file-prefix = "RacerAnswerParser"

%{
#include "RacerAnswerDriver.h"
#include "RacerError.h"

#include <string>

#ifndef YY_DECL
// Announce to bison the prototype we want for the lexing function
#define YY_DECL								\
  int yylex (YYSTYPE* yylval,						\
	     yy::location* yylloc,					\
	     dlvhex::racer::RacerAnswerDriver& driver)
// declare YY_DECL function
YY_DECL;
#endif /* YY_DECL */
%}

// this is the parsing context, passed as parameters to the
// yy::RacerAnswerParser ctor
%parse-param { dlvhex::racer::RacerAnswerDriver& driver }
%parse-param { dlvhex::racer::Answer& answer }

// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { dlvhex::racer::RacerAnswerDriver& driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
%debug
%error-verbose
%verbose /* really verbose output */

// this is YYSTYPE, the semantics
%union {
  int ival;
  std::string* sval;
  Term* termval;
  Tuple* tupleval;
}

%type <sval> nsid;
%type <termval> individual;
%type <tupleval> tuple;
%type <tupleval> pair;

%token <sval> STRING
%token <ival> NUMBER
%token NIL
%token TRUE
%token ANSWER
%token ERROR

// automagically delete all dynamically allocated objects after the
// parsing process
%destructor { delete $$; } STRING nsid individual pair tuple

// in debugging mode output the content of the corresponding terminal
// symbol
%printer    { debug_stream() << *$$; } STRING
%printer    { debug_stream() << $$; } NUMBER

%%

racer: ANSWER message '\n'
     | ERROR STRING '\n'
       {
	 answer.setErrorMessage(*$2);

	 // Racer returns "ABox XXX is incoherent." for 'old' Racer
	 // queries, and "ABox XXX is inconsistent! Querying denied."
	 // for nRQL queries.
	 if ($2->find("incoherent") != std::string::npos ||
	     $2->find("inconsistent") != std::string::npos)
	   {
	     // if kb gets inconsistent just return without error and
	     // set incoherent flag
	     answer.setIncoherent(true);
	   }
	 else
	   {
	     throw dlvhex::racer::RacerParsingError(*$2);
	   }
       }
;

// a Racer answer message is either a boolean, a list or a status
message: boolean | list | status
;

// a Racer boolean answer is either "T" or "NIL"
boolean: TRUE
         {
	   answer.setAnswer(true);
	   answer.setTuples(std::vector<Tuple>(1));
	 }
       | NIL
         {
	   answer.setAnswer(false);
	 }
;


// a Racer list is either a list of individuals, a list of pairs or a
// list of tuples
list: '(' individuals ')'
    | '(' pairs ')'
    | '(' tuples ')'
;

// a Racer status message, just ignore it
status: ':' STRING
      | '|' STRING '|'
      | STRING
;

// just add the sequence of individuals to the answer
individuals: individual
             {
	       answer.addTuple(Tuple(1, *$1));
	     }
           | individuals individual
             { 
	       answer.addTuple(Tuple(1, *$2));
	     }
;

// add the parsed Tuple to the answer
pairs: '(' pair ')'
       {
	 answer.addTuple(*$2);
       }
     | pairs '(' pair ')'
       {
	 answer.addTuple(*$3);
       }
;

// a Racer pair is a pair of individuals -> use both individuals in a
// new Tuple
pair: individual individual
      {
	$$ = new Tuple;
        $$->push_back(*$1);
        $$->push_back(*$2);
      }
;

// add the parsed Tuple to the answer
tuples: '(' tuple ')'
        {
	  answer.addTuple(*$2);
	}
      | tuples '(' tuple ')'
        {
	  answer.addTuple(*$3);
	}
;

// a Racer tuple consists of a pair (var ind) -> just use the
// individual
tuple: '(' variable individual ')'
       {
	 $$ = new Tuple(1, *$3);
       }
     | tuple '(' variable individual ')'
       {
	 $1->push_back(*$4);
       }
;


// an individual is a symbol (maybe with namespace) or a number
individual: '|' nsid '#' STRING '|'
            {
	      $$ = new Term(*$2 + "#" + *$4, true);
	    }
          | STRING
            {
	      $$ = new Term(*$1, true);
	    }
          | NUMBER
            {
	      $$ = new Term($1);
	    }
;

// Racer has 4 types of variables
variable: '?' STRING
        | '$' '?' STRING
        | '?' '*' STRING
        | '$' '?' '*' STRING
;

// this is a rather weak version of a namespace identifier
nsid: STRING ':' '/' '/' STRING
      {
	$$ = new std::string(*$1 + "://" + *$5);
      }
    | STRING ':' STRING
      {
	$$ = new std::string(*$1 + ":" + *$3);
      }
;


%%

// error method of bison parser -> call error method of the
// corresponding driver
void
yy::RacerAnswerParser::error(const yy::RacerAnswerParser::location_type& l,
			     const std::string& m)
{
  driver.error(l, m);
}


// abuse YY_DECL as bison callback for a pure C++ parsing engine
YY_DECL
{
  RacerFlexLexer* lex = driver.getLexer();
  lex->lexval = yylval; // set current semantic value
  lex->lexloc = yylloc; // and the current location,
  return lex->yylex (); // finally call the drivers lexer
}
