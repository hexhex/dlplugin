/* -*- C++ -*- */

/**
 * @file   HexDLScanner.lpp
 * @author Thomas Krennwallner
 * @date   Sat Nov  4 15:24:36 2006
 * 
 * @brief  Defines HexDLFlexLexer::yylex() method.
 * 
 * 
 */

%{
#include "HexDLDriver.h"
#include "HexDLFlexLexer.h"

#include <sstream>

// keep the HexDLRewriterFlexLexer as close as possible to the C version
#define yylval (*(yy::HexDLParser::semantic_type*)lexval)
#define yylloc ((yy::HexDLParser::location_type*)lexloc)
#define driver (*lexdrv)
%}

%option c++ noyywrap nounput batch debug
%option yyclass="HexDLFlexLexer"
%option prefix="yyDL"

NEWLINE         \r?\n
BLANK           [ \t]
STRING          [A-Za-z][A-Za-z_0-9\'\_]*
QUOTED_STRING   \"[^\"]*\"
NUMBER          (\-)?[0-9]+

COMMENT         {BLANK}*%.*{NEWLINE}

PLUSOP          "+="
MINUSOP         "-="
EQUALS          "=="
NEQUAL          "!="

INPUTLIST       \[[^\]]+\]
OUTPUTLIST      \([^\)]+\)

DLATOM          DL{INPUTLIST}{OUTPUTLIST}?
DLCATOM         &dlC{INPUTLIST}{OUTPUTLIST}
DLRATOM         &dlR{INPUTLIST}{OUTPUTLIST}
DLDRATOM        &dlDR{INPUTLIST}{OUTPUTLIST}
DLCQATOM        &dlCQ{INPUTLIST}{OUTPUTLIST}?
DLUCQATOM       &dlUCQ{INPUTLIST}{OUTPUTLIST}?


%{
// warning: we don't allow one of (), in SUBDELIMS, otw. we can't use
// URI(X) or URI(X,Y) as input query in an cq- or ucq-atom -> you have
// to PCTENCODE URIs with (),
%}

GENDELIMS       [\:\/\?\#\[\]\@]
SUBDELIMS       [!$&\'*+;=]
RESERVED        {GENDELIMS}|{SUBDELIMS}

HEXDIG          [0-9a-fA-F]
PCTENCODED      %{HEXDIG}{HEXDIG}
UNRESERVED      [A-Za-z0-9\-._~]*
REGNAME         ({UNRESERVED}|{PCTENCODED}|{SUBDELIMS})*

DECOCTET        ([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])
IPV4ADDRESS     {DECOCTET}\.{DECOCTET}\.{DECOCTET}\.{DECOCTET}

PORT            [0-9]*
HOST            {IPV4ADDRESS}|{REGNAME}
USERINFO        ({UNRESERVED}|{PCTENCODED}|{SUBDELIMS}|:)*
AUTHORITY       ({USERINFO}@)?{HOST}(:{PORT})?

PCHAR           {UNRESERVED}|{PCTENCODED}|{SUBDELIMS}|:|@
SEGMENT         {PCHAR}*
SEGMENTNZ       {PCHAR}+
SEGMENTNZNC     ({UNRESERVED}|{PCTENCODED}|{SUBDELIMS}|@)+

PATHEMPTY       ""
PATHROOTLESS    {SEGMENTNZ}(\/{SEGMENT})*
PATHNOSCHEME    {SEGMENTNZNC}(\/{SEGMENT})*
PATHABSOLUTE    \/({SEGMENTNZ}(\/{SEGMENT})*)?
PATHABEMPTY     (\/{SEGMENT})*

PATH            {PATHABEMPTY}|{PATHABSOLUTE}|{PATHNOSCHEME}|{PATHROOTLESS}|{PATHEMPTY}

FRAGMENT        ({PCHAR}|[\/\?])*
QUERY           ({PCHAR}|[\/\?])*
HIERPART        (\/\/{AUTHORITY}{PATHABEMPTY})|({PATHABSOLUTE})|({PATHROOTLESS})|({PATHEMPTY})
SCHEME          [A-Za-z][A-Za-z0-9+-.]*

URI             {SCHEME}:{HIERPART}(\?{QUERY})?(\#{FRAGMENT})?


%x dlatominput dlatomoutput dlatomend

%%

%{
// set begin location to the end location
yylloc->step();
%}

%{
// abbreviate it as token
typedef yy::HexDLParser::token token;
%}


<INITIAL>{

  {COMMENT}  ECHO; yylloc->lines(1);

  {DLATOM} {
    yyless(2); // throw away "DL" and continue
    BEGIN(dlatominput);
    return token::DLATOM;
  }

  ({DLCATOM}|{DLRATOM}) {
    yylval.sval = new std::string(yytext + 1, 3);
    yyless(4); // throw away "&dl(C|R)" and continue
    BEGIN(dlatominput);
    return token::DLEXTATOM;
  }

  {DLDRATOM} {
    yylval.sval = new std::string(yytext + 1, 4);
    yyless(5); // throw away "&dlDR" and continue
    BEGIN(dlatominput);
    return token::DLEXTATOM;
  }

  {DLCQATOM} {
    yyless(5); // throw away "&dlCQ" and continue
    BEGIN(dlatominput);
    return token::CQATOM;
  }

  {DLUCQATOM} {
    yyless(6); // throw away "&dlUCQ" and continue
    BEGIN(dlatominput);
    return token::UCQATOM;
  }

}


<dlatominput>{

  " v " {
    return yy::HexDLParser::token_type('v');
  }

  [\[\,\;\_\-\(\)] {
    return yy::HexDLParser::token_type(*yytext);
  }

  ({URI}|{STRING}|{QUOTED_STRING}|{EQUALS}|{NEQUAL}) {
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  {NUMBER} {
    std::istringstream(yytext) >> yylval.ival;
    return token::NUMBER; 
  }

  ({PLUSOP}|{MINUSOP}) {
    yylval.cval = *yytext;
    return token::PMOP;
  }

  [\]] {
    // these symbol may begin a dl-atom output or an dl-atom end
    BEGIN(dlatomend);
    return yy::HexDLParser::token_type(*yytext);
  }

}


<dlatomend>{

  "(" {
    // ok, we have an output, parse that thing
    BEGIN(dlatomoutput);
    return yy::HexDLParser::token_type(*yytext);
  }

  [\,\.] {
    // _after_ a dl-atom we can only get a , or a .
    BEGIN(INITIAL);
    yylval.cval = *yytext;
    return token::SENTINEL;
  }

}


<dlatomoutput>{

  ({URI}|{STRING}|{QUOTED_STRING}) {
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  {NUMBER} {
    std::istringstream(yytext) >> yylval.ival;
    return token::NUMBER; 
  }

  [\_\,] {
    // special chars in an output
    return yy::HexDLParser::token_type(*yytext);
  }

  [\)] {
    // these symbol ends a dl-atom
    BEGIN(dlatomend);
    return yy::HexDLParser::token_type(*yytext);
  }

}


<dlatominput,dlatomoutput,dlatomend>{BLANK}+  /* skip blanks */ yylloc->step();


<*>{NEWLINE}                yylloc->lines(1); ECHO;


<*>.                        yylloc->step(); ECHO;


%%

