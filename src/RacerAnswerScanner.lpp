/* -*- C++ -*- */

/**
 * @file   RacerAnswerScanner.lpp
 * @author Thomas Krennwallner
 * @date   Fri Mar 17 21:57:18 2006
 * 
 * @brief  Defines RacerFlexLexer::yylex() method.
 * 
 */

%{
#include <iostream>
#include <sstream>
#include <string>

// for yy::location 
#include "RacerAnswerParser.hpp"
#include "RacerAnswerDriver.h"
#include "RacerFlexLexer.h"

using namespace std;

// keep the RacerFlexLexer as close as possible to the C version
#define yylval (*(yy::RacerAnswerParser::semantic_type*)lexval)
#define yylloc ((yy::RacerAnswerParser::location_type*)lexloc)
#define driver (*lexdrv)
%}

%option c++ noyywrap nounput batch debug
%option yyclass="RacerFlexLexer"
%option prefix="yyRacer"

NEWLINE         \r?\n
BLANK           [ \t]
NUMBER          (\-)?[0-9]+
STRING          [A-Za-z][A-Za-z0-9_\-\./%]*
QUOTED_STRING   \\\"[^\"]*\\\"

GENDELIMS       [\:\/\?\#\[\]\@]
SUBDELIMS       [\!\$\&\'()\*\+\,\;\=]
RESERVED        (({GENDELIMS})|({SUBDELIMS}))
HEXDIG          [0-9a-fA-F]
PCTENCODED      %{HEXDIG}{HEXDIG}
UNRESERVED      [A-Za-z0-9\-\.\_\~]*
REGNAME         (({UNRESERVED})|({PCTENCODED})|({SUBDELIMS}))*

PORT            [0-9]*
HOST            {REGNAME}
USERINFO        (({UNRESERVED})|({PCTENCODED})|({SUBDELIMS})|(:))*
AUTHORITY       ({USERINFO}@)?{HOST}(:{PORT})?

PCHAR           (({UNRESERVED})|({PCTENCODED})|({SUBDELIMS})|(:)|(@))
SEGMENT         ({PCHAR})*
SEGMENTNZ       ({PCHAR})+
SEGMENTNZNC     (({UNRESERVED})|({PCTENCODED})|({SUBDELIMS})|(@))+

PATHEMPTY       ""
PATHROOTLESS    {SEGMENTNZ}(\/{SEGMENT})*
PATHNOSCHEME    {SEGMENTNZNC}(\/{SEGMENT})*
PATHABSOLUTE    \/({SEGMENTNZ}(\/{SEGMENT})*)?
PATHABEMPTY     (\/{SEGMENT})*

PATH            (({PATHABEMPTY})|({PATHABSOLUTE})|({PATHNOSCHEME})|({PATHROOTLESS})|({PATHEMPTY}))

FRAGMENT        (({PCHAR})|[\/\?])*
QUERY           (({PCHAR})|[\/\?])*
HIERPART        (\/\/{AUTHORITY}{PATHABEMPTY})|(\/{PATHABSOLUTE})|(\/{PATHROOTLESS})|(\/{PATHEMPTY})
SCHEME          [A-Za-z][A-Za-z0-9+-.]*
URI             {SCHEME}:{HIERPART}(\?{QUERY})?(\#{FRAGMENT})?

%x racererror raceranswer eatanswerfudge eaterrorfudge answertrailer

%{
// advance the end location after each tokenizing step
#define YY_USER_ACTION  yylloc->columns(yyleng);
%}

%%

%{
// set begin location to the end location
yylloc->step();
%}

%{
  // abbreviate it as token
  typedef yy::RacerAnswerParser::token token;
%}

^":error"  BEGIN(eaterrorfudge); return token::ERROR;
^":answer" BEGIN(eatanswerfudge); return token::ANSWER;


<eatanswerfudge>{

  [^\"]*   /* eat non-" chars */ yylloc->step();
  "\""     BEGIN(raceranswer); yylloc->step();

}


<eaterrorfudge>{

  [0-9 ]*         /* eat all numbers and blanks */ yylloc->step();
  [^0-9 ]         BEGIN(racererror); yyless(0);

}


<racererror>{

  [^\"]* {
    // this is the error message
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  "\""            BEGIN(answertrailer); yyless(0);

}


<raceranswer>{

  "NIL\""         BEGIN(answertrailer); return token::NIL;
  "T\""           BEGIN(answertrailer); return token::TRUE;
  "\""            BEGIN(answertrailer); yylloc->step();

  {URI} {
     yylval.sval = new std::string(yytext);
     return token::URI;
  }

  [()|$*?]        return yy::RacerAnswerParser::token_type(*yytext);

  {STRING} {
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  {QUOTED_STRING} {
    yylval.sval = new std::string(yytext + 2, yyleng - 4); // skip \"
    return token::STRING;
  }

  {NUMBER} {
    std::istringstream(yytext) >> yylval.ival;
    return token::NUMBER; 
  }

}


<answertrailer>{

  \"[^\"]*\" {
    // get the warning message
    BEGIN(INITIAL);
    yylval.sval = new std::string(yytext + 1, yyleng - 2); // skip "
    return token::STRING;
  }

}


<*>{BLANK}+       /* skip blanks */ yylloc->step();

{NEWLINE}         yylloc->lines(yyleng); return yy::RacerAnswerParser::token_type(*yytext);

.                 driver.error(*yylloc, "invalid character");

%%

