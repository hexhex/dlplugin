/* dlvhex-dlplugin -- Integration of Answer-Set Programming and Description Logics.
 *
 * Copyright (C) 2005, 2006, 2007  Thomas Krennwallner
 * 
 * This file is part of dlvhex-dlplugin.
 *
 * dlvhex-dlplugin is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * dlvhex-dlplugin is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dlvhex-dlplugin; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */


/**
 * @file   RacerAnswerScanner.lpp
 * @author Thomas Krennwallner
 * @date   Fri Mar 17 21:57:18 2006
 * 
 * @brief  Defines RacerFlexLexer::yylex() method.
 * 
 * @todo   Add Host IP stuff to URI regex.
 */

%{
#include <iostream>
#include <sstream>
#include <string>

// for yy::location 
#include "RacerAnswerParser.hpp"
#include "RacerAnswerDriver.h"
#include "RacerFlexLexer.h"

using namespace std;

// keep the RacerFlexLexer as close as possible to the C version
#define yylval (*(yy::RacerAnswerParser::semantic_type*)lexval)
#define yylloc ((yy::RacerAnswerParser::location_type*)lexloc)
#define driver (*lexdrv)
%}

%option c++ noyywrap nounput batch debug
%option yyclass="RacerFlexLexer"
%option prefix="yyRacer"
%option case-insensitive

NEWLINE         \r?\n
BLANK           [ \t]
NUMBER          (\-)?[0-9]+
STRING          [A-Za-z][A-Za-z0-9_\-\./%]*
QUOTED_STRING   \\\"[^\"]*\\\"

%{
// the following URI regexp is accourding to the ABNF syntax of URIs
// in http://www.ietf.org/rfc/rfc3986.txt

///@todo HOST is not complete, IP-Literal (IPv6 stuff) is missing
%}

GENDELIMS       [\:\/\?\#\[\]\@]
SUBDELIMS       [\!\$\&\'()\*\+\,\;\=]
RESERVED        {GENDELIMS}|{SUBDELIMS}

HEXDIG          [0-9a-fA-F]
PCTENCODED      %{HEXDIG}{HEXDIG}
UNRESERVED      [A-Za-z0-9\-\.\_\~]*
REGNAME         ({UNRESERVED}|{PCTENCODED}|{SUBDELIMS})*

DECOCTET        ([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])
IPV4ADDRESS     {DECOCTET}\.{DECOCTET}\.{DECOCTET}\.{DECOCTET}

PORT            [0-9]*
HOST            {IPV4ADDRESS}|{REGNAME}
USERINFO        ({UNRESERVED}|{PCTENCODED}|{SUBDELIMS}|:)*
AUTHORITY       ({USERINFO}@)?{HOST}(:{PORT})?

PCHAR           {UNRESERVED}|{PCTENCODED}|{SUBDELIMS}|:|@
SEGMENT         {PCHAR}*
SEGMENTNZ       {PCHAR}+
SEGMENTNZNC     ({UNRESERVED}|{PCTENCODED}|{SUBDELIMS}|@)+

PATHEMPTY       ""
PATHROOTLESS    {SEGMENTNZ}(\/{SEGMENT})*
PATHNOSCHEME    {SEGMENTNZNC}(\/{SEGMENT})*
PATHABSOLUTE    \/({SEGMENTNZ}(\/{SEGMENT})*)?
PATHABEMPTY     (\/{SEGMENT})*

PATH            {PATHABEMPTY}|{PATHABSOLUTE}|{PATHNOSCHEME}|{PATHROOTLESS}|{PATHEMPTY}

FRAGMENT        ({PCHAR}|[\/\?])*
QUERY           ({PCHAR}|[\/\?])*
HIERPART        (\/\/{AUTHORITY}{PATHABEMPTY})|({PATHABSOLUTE})|({PATHROOTLESS})|({PATHEMPTY})
SCHEME          [A-Za-z][A-Za-z0-9+-.]*

URI             {SCHEME}:{HIERPART}(\?{QUERY})?(\#{FRAGMENT})?


%x racererror raceranswer eatanswerfudge eaterrorfudge answertrailer

%{
// advance the end location after each tokenizing step
#define YY_USER_ACTION  yylloc->columns(yyleng);
%}

%%

%{
// set begin location to the end location
yylloc->step();
%}

%{
  // abbreviate it as token
  typedef yy::RacerAnswerParser::token token;
%}

^":error"  BEGIN(eaterrorfudge); return token::ERROR;
^":answer" BEGIN(eatanswerfudge); return token::ANSWER;


<eatanswerfudge>{

  [^\"]*   /* eat non-" chars */ yylloc->step();
  "\""     BEGIN(raceranswer); yylloc->step();

}


<eaterrorfudge>{

  [0-9 ]*         /* eat all numbers and blanks */ yylloc->step();
  [^0-9 ]         BEGIN(racererror); yyless(0);

}


<racererror>{

  [^\"]* {
    // this is the error message
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  "\""            BEGIN(answertrailer); yyless(0);

}


<raceranswer>{

  "NIL\""         BEGIN(answertrailer); return token::NIL;
  "T\""           BEGIN(answertrailer); return token::TRUE;
  "\""            BEGIN(answertrailer); yylloc->step();

  {URI} {
     yylval.sval = new std::string(yytext);
     return token::URI;
  }

  [()|$*?]        return yy::RacerAnswerParser::token_type(*yytext);

  {STRING} {
    yylval.sval = new std::string(yytext);
    return token::STRING;
  }

  {QUOTED_STRING} {
    yylval.sval = new std::string(yytext + 2, yyleng - 4); // skip \"
    return token::STRING;
  }

  {NUMBER} {
    std::istringstream(yytext) >> yylval.ival;
    return token::NUMBER; 
  }

}


<answertrailer>{

  \"[^\n]*\n {
    // get the warning message
    BEGIN(INITIAL);
    yylval.sval = new std::string(yytext + 1, yyleng - 3); // skip "\n
    yyless(yyleng - 1); // add \n into the stream
    return token::STRING;
  }

}


<*>{BLANK}+       /* skip blanks */ yylloc->step();

{NEWLINE}         yylloc->lines(1); return yy::RacerAnswerParser::token_type(*yytext);

.                 driver.error(*yylloc, "invalid character");

%%


// Local Variables:
// mode: C++
// End:
