/* dlvhex-dlplugin -- Integration of Answer-Set Programming and Description Logics.
 *
 * Copyright (C) 2005, 2006, 2007  Thomas Krennwallner
 * 
 * This file is part of dlvhex-dlplugin.
 *
 * dlvhex-dlplugin is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * dlvhex-dlplugin is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dlvhex-dlplugin; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */


/**
 * @file   HexDLParser.ypp
 * @author Thomas Krennwallner
 * @date   Sun Nov  5 09:46:05 2006
 * 
 * @brief  A bison C++ parser.
 * 
 * 
 */


%skeleton "lalr1.cc"
%define "parser_class_name" "HexDLParser"
%defines
%file-prefix = "HexDLParser"
%require "2.2"

%{
#include "HexDLDriver.h"
#include "HexDLRewriter.h"

#include <dlvhex/Term.h>
#include <dlvhex/Atom.h>

#include <sstream>
#include <string>
#include <iterator>

  // why do we need this forward declaration?
  namespace dlvhex {
    namespace dl {
      class HexDLDriver;
    }
  }

%}

// this is the parsing context, passed as parameters to the
// yy::HexDLRewriterParser ctor
%parse-param { dlvhex::dl::HexDLDriver& driver }
%parse-param { dlvhex::dl::DLAtomInput& dlinput }

// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { dlvhex::dl::HexDLDriver& driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
%debug
%error-verbose
%verbose /* really verbose output */

// this is YYSTYPE, the semantics
%union {
  char cval;
  std::string* sval;
  int ival;
  DLVHEX_NAMESPACE Term* termval;
  DLVHEX_NAMESPACE Tuple* tupleval;
  DLVHEX_NAMESPACE AtomPtr* atomval;
  DLVHEX_NAMESPACE AtomSet* atomsetval;
  boost::ptr_vector<DLVHEX_NAMESPACE AtomSet>* atomsetsval;
  dlvhex::dl::HexDLRewriterBase* dlrewriterval;
}

%token <cval> SENTINEL PMOP
%token <sval> STRING DLEXTATOM
%token <ival> NUMBER
%token DLATOM CQATOM UCQATOM
%type <sval> dlquery
%type <dlrewriterval> dlatom
%type <atomval> op atom
%type <atomsetval> ops cq
%type <atomsetsval> ucq
%type <termval> term
%type <tupleval> terms output

// define FlexLexer part *after* the definitions of the various types
%{

#include "HexDLFlexLexer.h"

// Announce to bison the prototype we want for the lexing function
#define YY_DECL                                                 \
yy::HexDLParser::token_type                                     \
yylex (yy::HexDLParser::semantic_type* yylval,                  \
       yy::HexDLParser::location_type* yylloc,                  \
       dlvhex::dl::HexDLDriver& driver)

// declare YY_DECL function for the parser
YY_DECL;

%}

// automagically delete all dynamically allocated objects after the
// parsing process
%destructor { delete $$; } STRING dlatom

// in debugging mode output the content of the corresponding terminal
// symbol
%printer    { debug_stream() << *$$; } STRING

%%

// either no dlatoms or a bunch of dlatoms
dlatoms: /* empty */
       | dlatoms dlatom SENTINEL
         {
	   DLVHEX_NAMESPACE Literal* l = $2->getLiteral();
	   // replace the parsed dl-atom
	   driver.getOutput() << *l << $3;
	   delete l;
	   delete $2;
	 }
       ;


// This rule keeps track of the various forms of the dl-atom
// rewriters. We rewrite dl-atoms to &dlC/&dlR/&dlDR/&dlCQ/&dlUCQ
// external atoms, &dl{C,R}, &dlCQ and &dlUCQ external atoms are
// handled here as well.
dlatom: DLATOM '[' dlquery ']' output
        {
	  //
	  // create a rewriter without dl-atom ops
	  //
	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getOntology(), dlinput, DLVHEX_NAMESPACE AtomSet(), $3, $5);
	}
      | DLATOM '[' ops ';' dlquery ']' output
        {
	  //
	  // create a rewriter with dl-atom ops
	  //

	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getOntology(), dlinput, *$3, $5, $7);
	  delete $3;
	}
      | DLATOM '[' cq ']' output
        {
	  //
	  // create a rewriter with cq-atom ops
	  //

	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getOntology(), dlinput, DLVHEX_NAMESPACE AtomSet(), $3, $5);
	}
      | DLATOM '[' ops ';' cq ']' output
        {
	  //
	  // create a rewriter with cq-atom ops
	  //

	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getOntology(), dlinput, *$3, $5, $7);
	  delete $3;
	}
      | DLATOM '[' ucq ']' output
        {
	  //
	  // create a rewriter with ucq-atom ops
	  //

	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getOntology(), dlinput, DLVHEX_NAMESPACE AtomSet(), $3, $5);
	}
      | DLATOM '[' ops ';' ucq ']' output
        {
	  //
	  // create a rewriter with ucq-atom ops
	  //

	  $$ = new dlvhex::dl::DLAtomRewriter(driver.getOntology(), dlinput, *$3, $5, $7);
	  delete $3;
	}
      | CQATOM '[' terms ']' output
        { 
	  // a cq-atom is the external atom
	  // &dlCQ[uri,a,b,c,d,q](X_1,...X_n), we rewrite it to
	  // &dlCQn[uri,a,b,c,d,q](X_1,...,X_n)

	  std::ostringstream oss;
	  oss << "dlCQ" << $5->size();

	  DLVHEX_NAMESPACE AtomPtr eap(new DLVHEX_NAMESPACE ExternalAtom(oss.str(), *$5, *$3, 0));
	  $$ = new dlvhex::dl::ExtAtomRewriter(eap);

	  delete $3;
	  delete $5;
	}
      | UCQATOM '[' terms ']' output
        { 
	  // a ucq-atom is the external atom
	  // &dlUCQ[uri,a,b,c,d,q](X_1,...X_n), we rewrite it to
	  // &dlUCQn[uri,a,b,c,d,q](X_1,...,X_n)

	  std::ostringstream oss;
	  oss << "dlCQ" << $5->size();

	  DLVHEX_NAMESPACE AtomPtr eap(new DLVHEX_NAMESPACE ExternalAtom(oss.str(), *$5, *$3, 0));
	  $$ = new dlvhex::dl::ExtAtomRewriter(eap);

	  delete $3;
	  delete $5;
	}
      | DLEXTATOM '[' terms ']' output
        {
	  // create simple dlatom rewriter
	  DLVHEX_NAMESPACE AtomPtr eap(new DLVHEX_NAMESPACE ExternalAtom(*$1, *$5, *$3, 0));
	  $$ = new dlvhex::dl::ExtAtomRewriter(eap);

	  delete $1;
	  delete $3;
	  delete $5;
	}
      ;


// a dl-query is a STRING or a negated STRING
dlquery: STRING
         {
	   $$ = $1;
	 }
       | '-' STRING
         {
	   $$ = $2;
	   $$->insert(0, 1, '-');
	 }
       ;


// a query atom
atom: dlquery '(' term ')'
      {
	DLVHEX_NAMESPACE Tuple t;
	t.push_back(*$3);

	bool neg = (*$1)[0] == '-';
	$$ = new DLVHEX_NAMESPACE AtomPtr(new DLVHEX_NAMESPACE Atom(neg ? $1->substr(1) : *$1, t, neg));

	delete $1;
	delete $3;
      }
    | dlquery '(' term ',' term ')'
      {
	DLVHEX_NAMESPACE Tuple t;
	t.push_back(*$3);
	t.push_back(*$5);

	bool neg = (*$1)[0] == '-';
	$$ = new DLVHEX_NAMESPACE AtomPtr(new DLVHEX_NAMESPACE Atom(neg ? $1->substr(1) : *$1, t, neg));

	delete $1;
	delete $3;
	delete $5;
      }


// a conjunctive query
cq: atom
    {
      $$ = new DLVHEX_NAMESPACE AtomSet;
      $$->insert(*$1);
      delete $1;
    }
  | cq ',' atom
    {
      $$ = $1;
      $$->insert(*$3);
      delete $3;
    }


// a union conjunctive query
ucq: cq 'v' cq
     {
       $$ = new boost::ptr_vector<DLVHEX_NAMESPACE AtomSet>;
       $$->push_back($1);
       $$->push_back($3);
     }
   | ucq 'v' cq
     {
       $$ = $1;
       $$->push_back($3);
     }


// the output list
output: /* empty */
        {
	  $$ = new DLVHEX_NAMESPACE Tuple;
	}
      | '(' ')'
        {
	  $$ = new DLVHEX_NAMESPACE Tuple;
	}
      | '(' terms ')'
        {
	  $$ = $2;
	}
      ;


// list of terms
terms: term
       {
	 $$ = new DLVHEX_NAMESPACE Tuple(1, *$1);
	 delete $1;
       }
     | terms ',' term
       {
	 $$ = $1;
	 $$->push_back(*$3);
	 delete $3;
       }
     ;


// a term is either a string, a number or an anonymous variable
term: STRING
      {
	$$ = new DLVHEX_NAMESPACE Term(*$1);
	delete $1;
      }
    | NUMBER
      {
	$$ = new DLVHEX_NAMESPACE Term($1);
      }
    | '_'
      {
	$$ = new DLVHEX_NAMESPACE Term;
      }
    ;



// list of operations
ops: op
     {
       $$ = new DLVHEX_NAMESPACE AtomSet;
       $$->insert(*$1);
       delete $1;
     }
   | ops ',' op
     {
       $$ = $1;
       $$->insert(*$3);
       delete $3;
     }
   ;


// an operation is either lhs += rhs or lhs -= rhs. For each lhs+=rhs
// resp. lhs-=rhs we create a pc(lhs,rhs) or pr(lhs,rhs)
// resp. mc(lhs,rhs) or mr(lhs,rhs) atom. Then, the DLAtomRewriter
// takes care of adding rules and input terms to the ext-atoms.
op: STRING PMOP STRING
    {
      dlvhex::dl::Ontology::shared_pointer ontology = driver.getOntology();

      if (!ontology)
	{
	  throw DLVHEX_NAMESPACE PluginError("Cannot rewrite dl-atoms, option --ontology is empty.");
	}

      std::string tmp;

      if ($1->find("\"-") == 0)
	{
	  tmp = ontology->getNamespace() + $1->substr(2, $1->length() - 3);
	}
      else if ($1->find("\"") == 0)
	{
	  tmp = ontology->getNamespace() + $1->substr(1, $1->length() - 2);
	}
      else if ($1->find("-") == 0)
	{
	  tmp = ontology->getNamespace() + $1->substr(1, $1->length() - 1);
	}
      else
	{
	  tmp = ontology->getNamespace() + *$1;
	}

      DLVHEX_NAMESPACE Tuple t;
      t.push_back(DLVHEX_NAMESPACE Term(tmp, true));
      t.push_back(DLVHEX_NAMESPACE Term(*$3));

      DLVHEX_NAMESPACE Term q(tmp);

      dlvhex::dl::TBox::ObjectsPtr concepts = ontology->getTBox().getConcepts();
      dlvhex::dl::TBox::ObjectsPtr roles = ontology->getTBox().getRoles();
      dlvhex::dl::TBox::ObjectsPtr datatypeRoles = ontology->getTBox().getDatatypeRoles();

      if ($2 == '+') // PMOP is +=
	{
	  if (concepts->find(q) != concepts->end())
	    {
	      $$ = new DLVHEX_NAMESPACE AtomPtr(new DLVHEX_NAMESPACE Atom("pc", t));
	    }
	  else if (roles->find(q) != roles->end() ||
		   datatypeRoles->find(q) != datatypeRoles->end()
		   )
	    {
	      $$ = new DLVHEX_NAMESPACE AtomPtr(new DLVHEX_NAMESPACE Atom("pr", t));
	    }
	  else
	    {
	      std::ostringstream oss;
	      oss << "Incompatible dl-atom-op `" << *$1 << "+=" << *$3 << "' supplied: ";
	      oss << "Cannot find " << q << " in " << ontology->getRealURI();
	      throw DLVHEX_NAMESPACE PluginError(oss.str());
	    }
	}
      else if ($2 == '-') // PMOP is -=
	{
	  if (concepts->find(q) != concepts->end())
	    {
	      $$ = new DLVHEX_NAMESPACE AtomPtr(new DLVHEX_NAMESPACE Atom("mc", t));
	    }
	  else if (roles->find(q) != roles->end() ||
		   datatypeRoles->find(q) != datatypeRoles->end()
		   )
	    {
	      $$ = new DLVHEX_NAMESPACE AtomPtr(new DLVHEX_NAMESPACE Atom("mr", t));
	    }
	  else
	    {
	      std::ostringstream oss;
	      oss << "Incompatible dl-atom-op `" << *$1 << "-=" << *$3 << "' supplied: ";
	      oss << "Cannot find " << q << " in " << ontology->getRealURI();
	      throw DLVHEX_NAMESPACE PluginError(oss.str());
	    }
	}
      else // hm, PMOP is neither '+' nor '-', this is a programming error
	{
	  assert(false);
	}

      delete $1;
      delete $3;
    }
  ;


%%


//
// error method of bison parser -> call error method of the
// corresponding driver
//
void
yy::HexDLParser::error(const yy::HexDLParser::location_type& l, const std::string& m)
{
  driver.error(l, m);
}


//
// abuse YY_DECL as bison callback for a pure C++ parsing engine
//
YY_DECL
{
  HexDLFlexLexer* lex = driver.getLexer();
  lex->lexval = yylval; // set current semantic value
  lex->lexloc = yylloc; // and the current location,
  return (yy::HexDLParser::token_type) lex->yylex (); // finally call the drivers lexer
} 


// Local Variables:
// mode: C++
// End:
